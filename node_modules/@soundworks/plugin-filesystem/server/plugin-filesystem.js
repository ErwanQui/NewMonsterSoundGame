"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _chokidar = _interopRequireDefault(require("chokidar"));

var _directoryTree = _interopRequireDefault(require("directory-tree"));

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _normalizePath = _interopRequireDefault(require("normalize-path"));

var _urlJoin = _interopRequireDefault(require("url-join"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultSchema = {};
const cwd = process.cwd();

function parseTree(tree, config) {
  if (config.publicDirectory) {
    function addUrl(obj) {
      // we need these two steps to handle properly absolute and relative paths
      // 1. relative from cwd (harmonize abs and rel)
      const pathFromCwd = _path.default.relative(cwd, obj.path); // 2. relative from the watched path


      const relPath = _path.default.relative(config.path, pathFromCwd); // 3. normalize according to platform (relPath could be in windows style)


      const normalizedPath = (0, _normalizePath.default)(relPath); // 4. then we just need to join publicDirectory w/ relpath to obtain the url
      // @note: using `path.join` will renormalize back to \\ on windows

      let url = (0, _urlJoin.default)('/', config.publicDirectory, normalizedPath);

      if (obj.type === 'directory') {
        url += '/';
      }

      obj.path = pathFromCwd; // better to not expose the server guts client-side

      obj.url = url;

      if (obj.children) {
        obj.children.forEach(addUrl);
      }
    }

    addUrl(tree);
  }

  return tree;
} // class Node


const pluginFactory = function (AbstractPlugin) {
  return class PluginFilesystem extends AbstractPlugin {
    constructor(server, name, options) {
      super(server, name);
      this.excludeDotFiles = /(^|[\/\\])\../; // dot files

      const defaults = {
        directories: [],
        debounce: 50,
        // cf. https://www.npmjs.com/package/directory-tree
        dirTreeOptions: {
          attributes: ["size", "type", "extension"],
          normalizePath: true,
          exclude: this.excludeDotFiles
        }
      };
      this.options = this.configure(defaults, options); // regenerate schema from directories config

      const schema = Object.assign({}, defaultSchema);
      this.options.directories.forEach(config => {
        schema[config.name] = {
          type: 'any',
          nullable: true,
          default: null,
          filterChange: false
        };
      });
      this.server.stateManager.registerSchema(`s:${this.name}`, schema);
    }

    async start() {
      this.state = await this.server.stateManager.create(`s:${this.name}`);
      this.started();
      const promises = this.options.directories.map(async config => {
        const rootPath = config.path;

        if (!_fs.default.existsSync(rootPath) || !_fs.default.statSync(rootPath).isDirectory()) {
          await (0, _mkdirp.default)(rootPath);
        }

        return new Promise((resolve, reject) => {
          let watcher = null;

          const watch = async (firstLaunch = false) => {
            // initial tree update or after chokidar relaunch
            let tree = (0, _directoryTree.default)(rootPath, this.options.dirTreeOptions);
            tree = parseTree(tree, config);
            await this.state.set({
              [config.name]: tree
            }); // run chokidar.on('all') => getTree, parseTree

            const watcher = _chokidar.default.watch(rootPath, {
              ignored: this.excludeDotFiles,
              // ignore dotfiles
              persistent: true,
              ignoreInitial: true
            });

            watcher.on('all', (0, _lodash.default)((event, path) => {
              // update because of change
              let tree = (0, _directoryTree.default)(rootPath, this.options.dirTreeOptions);
              tree = parseTree(tree, config);
              this.state.set({
                [config.name]: tree
              });
            }, this.options.debounce));
            watcher.on('ready', () => {
              if (firstLaunch) {
                resolve();
              }
            });
            watcher.on('error', err => {
              console.log(`${this.name}: chokidar error watching ${rootPath}`);
              console.error(err);
              reject(err);
            }); // workaround `chokidar` problem
            // we need to relaunch everything because when recreating
            // a folder with the same name as one that as been previously
            // unlinked, its content is not watched.
            //
            // @note - maybe its when creating a folder w/ content (but probably not)
            // @todo - open an issue with a proper report file

            const unlinkedDir = new Set();
            watcher.on('unlinkDir', path => unlinkedDir.add(path));
            watcher.on('addDir', path => {
              if (unlinkedDir.has(path)) {
                watcher.close();
                watch(false);
              }
            });
          };

          watch(true); // init first watch
        });
      });

      try {
        await Promise.all(promises);
        this.ready();
      } catch (err) {
        this.error(err.message);
      }
    }

    connect(client) {
      super.connect(client);
    }

    disconnect(client) {
      super.disconnect(client);
    }

    subscribe(callback) {
      const unsubscribe = this.state.subscribe(callback);
      return unsubscribe;
    }

    getValues() {
      return this.state.getValues();
    }

    get(name) {
      return this.state.get(name);
    }

  };
};

var _default = pluginFactory;
exports.default = _default;